<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.0" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_0.xsd">
  <name>CY8C4248BZI_L489</name>
  <version>0.1</version>
  <description>PSoC 4200L</description>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <peripherals>
    <peripheral>
      <name>DMAC</name>
      <description>DMAC Registers</description>
      <baseAddress>0x0</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DMAC_CTL</name>
          <description>DMA controller control register</description>
          <addressOffset>0x40101000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Global DMAC enable</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>DMA controller is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>DMA controller is enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_STATUS</name>
          <description>DMA controller status register</description>
          <addressOffset>0x40101010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Specifies the index of the currently active data transfer. This value increases from '0' to the DATA_NR field specified of the currently active descriptor control word.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CH_ADDR</name>
              <description>Specifies the channel number of the currently active channel. For example, if channel 7 is active, DMAC_STATUS.ACTIVE is '1' and STATUS.CH_ADDR is '7'.</description>
              <lsb>16</lsb>
              <msb>20</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>STATE</name>
              <description>State of the data transfer engine.</description>
              <lsb>24</lsb>
              <msb>26</msb>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDLE</name>
                  <description>Idle state when the DMA is not active.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOAD_DESCR</name>
                  <description>The DMA is loading the descriptor to the DMA transfer engine.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOAD_SRC</name>
                  <description>The DMA is getting the value from the source location.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STORE_DST</name>
                  <description>The DMA is storing the value at the destination location.</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STORE_DESCR</name>
                  <description>The DMA is updating the descriptors after completion of transfer.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_TRIG_DEACT</name>
                  <description>The DMA is waiting for the level sensitive trigger to deactivate.</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STORE_ERROR</name>
                  <description>There was an error during the transaction and the DMA is writing the error code to the channel status register.</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Specifies the priority of the currently active channel.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Specifies whether the PING descriptor ('0') or PONG descriptor ('1') of the channel is currently in use.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>Specifies if there is a currently active (pending) channel in the data transfer engine.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDLE</name>
                  <description>No currently active channel.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <description>Currently active channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_STATUS_SRC_ADDR</name>
          <description>Source address currently being used by the DMA controller</description>
          <addressOffset>0x40101014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>The source address currently being used by the DMA transfer engine. This field is provided for debug purposes. Note while reading the DMAC_STATUS, DMAC_STATUS_SRC_ADDR and DMAC_STATUS_DST_ADDR registers, the transfer engine may have advanced after one or more of these reads. Meaning the register values may not be related to each other.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_STATUS_DST_ADDR</name>
          <description>Destination address currently being used by the DMA controller</description>
          <addressOffset>0x40101018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>The destination address currently being used by the DMA transfer engine. This field is provided for debug purposes. Note while reading the DMAC_STATUS, DMAC_STATUS_SRC_ADDR and DMAC_STATUS_DST_ADDR registers, the transfer engine may have advanced after one or more of these reads. Meaning the register values may not be related to each other.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_STATUS_CH_ACT</name>
          <description>Channel activation status</description>
          <addressOffset>0x4010101C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Channel activation status. Bit i is associated to channel i. Software reads this field to get information on all actively pending channels (either in pending or in the data transfer engine).</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL0</name>
          <description>DMA channel 0 control register</description>
          <addressOffset>0x40101080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL1</name>
          <description>DMA channel 1 control register</description>
          <addressOffset>0x40101084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL2</name>
          <description>DMA channel 2 control register</description>
          <addressOffset>0x40101088</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL3</name>
          <description>DMA channel 3 control register</description>
          <addressOffset>0x4010108C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL4</name>
          <description>DMA channel 4 control register</description>
          <addressOffset>0x40101090</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL5</name>
          <description>DMA channel 5 control register</description>
          <addressOffset>0x40101094</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL6</name>
          <description>DMA channel 6 control register</description>
          <addressOffset>0x40101098</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL7</name>
          <description>DMA channel 7 control register</description>
          <addressOffset>0x4010109C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL8</name>
          <description>DMA channel 8 control register</description>
          <addressOffset>0x401010A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL9</name>
          <description>DMA channel 9 control register</description>
          <addressOffset>0x401010A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL10</name>
          <description>DMA channel 10 control register</description>
          <addressOffset>0x401010A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL11</name>
          <description>DMA channel 11 control register</description>
          <addressOffset>0x401010AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL12</name>
          <description>DMA channel 12 control register</description>
          <addressOffset>0x401010B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL13</name>
          <description>DMA channel 13 control register</description>
          <addressOffset>0x401010B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL14</name>
          <description>DMA channel 14 control register</description>
          <addressOffset>0x401010B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL15</name>
          <description>DMA channel 15 control register</description>
          <addressOffset>0x401010BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL16</name>
          <description>DMA channel 16 control register</description>
          <addressOffset>0x401010C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL17</name>
          <description>DMA channel 17 control register</description>
          <addressOffset>0x401010C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL18</name>
          <description>DMA channel 18 control register</description>
          <addressOffset>0x401010C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL19</name>
          <description>DMA channel 19 control register</description>
          <addressOffset>0x401010CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL20</name>
          <description>DMA channel 20 control register</description>
          <addressOffset>0x401010D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL21</name>
          <description>DMA channel 21 control register</description>
          <addressOffset>0x401010D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL22</name>
          <description>DMA channel 22 control register</description>
          <addressOffset>0x401010D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL23</name>
          <description>DMA channel 23 control register</description>
          <addressOffset>0x401010DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL24</name>
          <description>DMA channel 24 control register</description>
          <addressOffset>0x401010E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL25</name>
          <description>DMA channel 25 control register</description>
          <addressOffset>0x401010E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL26</name>
          <description>DMA channel 26 control register</description>
          <addressOffset>0x401010E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL27</name>
          <description>DMA channel 27 control register</description>
          <addressOffset>0x401010EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL28</name>
          <description>DMA channel 28 control register</description>
          <addressOffset>0x401010F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL29</name>
          <description>DMA channel 29 control register</description>
          <addressOffset>0x401010F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL30</name>
          <description>DMA channel 30 control register</description>
          <addressOffset>0x401010F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL31</name>
          <description>DMA channel 31 control register</description>
          <addressOffset>0x401010FC</addressOffset>
          <size>31</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0x401017F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Set to '1', when event is detected. Write INTR field with '1', to clear bit. Write INTR_SET field with '1', to set bit.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0x401017F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x401017F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Mask for corresponding field in INTR register.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0x401017FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Bitwise AND between the interrupt reguest (INTR) and mask (INTR_MASK) registers.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 0</description>
          <addressOffset>0x40101800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 0</description>
          <addressOffset>0x40101804</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PING_CTL</name>
          <description>Descriptor 0 control register for channel 0</description>
          <addressOffset>0x40101808</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 0</description>
          <addressOffset>0x4010180C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 0</description>
          <addressOffset>0x40101810</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 0</description>
          <addressOffset>0x40101814</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 0</description>
          <addressOffset>0x40101818</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 0</description>
          <addressOffset>0x4010181C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 1</description>
          <addressOffset>0x40101820</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 1</description>
          <addressOffset>0x40101824</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PING_CTL</name>
          <description>Descriptor 0 control register for channel 1</description>
          <addressOffset>0x40101828</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 1</description>
          <addressOffset>0x4010182C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 1</description>
          <addressOffset>0x40101830</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 1</description>
          <addressOffset>0x40101834</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 1</description>
          <addressOffset>0x40101838</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 1</description>
          <addressOffset>0x4010183C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 2</description>
          <addressOffset>0x40101840</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 2</description>
          <addressOffset>0x40101844</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PING_CTL</name>
          <description>Descriptor 0 control register for channel 2</description>
          <addressOffset>0x40101848</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 2</description>
          <addressOffset>0x4010184C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 2</description>
          <addressOffset>0x40101850</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 2</description>
          <addressOffset>0x40101854</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 2</description>
          <addressOffset>0x40101858</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 2</description>
          <addressOffset>0x4010185C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 3</description>
          <addressOffset>0x40101860</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 3</description>
          <addressOffset>0x40101864</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PING_CTL</name>
          <description>Descriptor 0 control register for channel 3</description>
          <addressOffset>0x40101868</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 3</description>
          <addressOffset>0x4010186C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 3</description>
          <addressOffset>0x40101870</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 3</description>
          <addressOffset>0x40101874</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 3</description>
          <addressOffset>0x40101878</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 3</description>
          <addressOffset>0x4010187C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 4</description>
          <addressOffset>0x40101880</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 4</description>
          <addressOffset>0x40101884</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PING_CTL</name>
          <description>Descriptor 0 control register for channel 4</description>
          <addressOffset>0x40101888</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 4</description>
          <addressOffset>0x4010188C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 4</description>
          <addressOffset>0x40101890</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 4</description>
          <addressOffset>0x40101894</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 4</description>
          <addressOffset>0x40101898</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 4</description>
          <addressOffset>0x4010189C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 5</description>
          <addressOffset>0x401018A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 5</description>
          <addressOffset>0x401018A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PING_CTL</name>
          <description>Descriptor 0 control register for channel 5</description>
          <addressOffset>0x401018A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 5</description>
          <addressOffset>0x401018AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 5</description>
          <addressOffset>0x401018B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 5</description>
          <addressOffset>0x401018B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 5</description>
          <addressOffset>0x401018B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 5</description>
          <addressOffset>0x401018BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 6</description>
          <addressOffset>0x401018C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 6</description>
          <addressOffset>0x401018C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PING_CTL</name>
          <description>Descriptor 0 control register for channel 6</description>
          <addressOffset>0x401018C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 6</description>
          <addressOffset>0x401018CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 6</description>
          <addressOffset>0x401018D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 6</description>
          <addressOffset>0x401018D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 6</description>
          <addressOffset>0x401018D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 6</description>
          <addressOffset>0x401018DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 7</description>
          <addressOffset>0x401018E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 7</description>
          <addressOffset>0x401018E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PING_CTL</name>
          <description>Descriptor 0 control register for channel 7</description>
          <addressOffset>0x401018E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 7</description>
          <addressOffset>0x401018EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 7</description>
          <addressOffset>0x401018F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 7</description>
          <addressOffset>0x401018F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 7</description>
          <addressOffset>0x401018F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 7</description>
          <addressOffset>0x401018FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR8_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 8</description>
          <addressOffset>0x40101900</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR8_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 8</description>
          <addressOffset>0x40101904</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR8_PING_CTL</name>
          <description>Descriptor 0 control register for channel 8</description>
          <addressOffset>0x40101908</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR8_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 8</description>
          <addressOffset>0x4010190C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR8_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 8</description>
          <addressOffset>0x40101910</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR8_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 8</description>
          <addressOffset>0x40101914</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR8_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 8</description>
          <addressOffset>0x40101918</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR8_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 8</description>
          <addressOffset>0x4010191C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR9_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 9</description>
          <addressOffset>0x40101920</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR9_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 9</description>
          <addressOffset>0x40101924</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR9_PING_CTL</name>
          <description>Descriptor 0 control register for channel 9</description>
          <addressOffset>0x40101928</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR9_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 9</description>
          <addressOffset>0x4010192C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR9_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 9</description>
          <addressOffset>0x40101930</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR9_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 9</description>
          <addressOffset>0x40101934</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR9_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 9</description>
          <addressOffset>0x40101938</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR9_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 9</description>
          <addressOffset>0x4010193C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR10_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 10</description>
          <addressOffset>0x40101940</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR10_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 10</description>
          <addressOffset>0x40101944</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR10_PING_CTL</name>
          <description>Descriptor 0 control register for channel 10</description>
          <addressOffset>0x40101948</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR10_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 10</description>
          <addressOffset>0x4010194C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR10_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 10</description>
          <addressOffset>0x40101950</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR10_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 10</description>
          <addressOffset>0x40101954</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR10_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 10</description>
          <addressOffset>0x40101958</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR10_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 10</description>
          <addressOffset>0x4010195C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR11_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 11</description>
          <addressOffset>0x40101960</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR11_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 11</description>
          <addressOffset>0x40101964</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR11_PING_CTL</name>
          <description>Descriptor 0 control register for channel 11</description>
          <addressOffset>0x40101968</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR11_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 11</description>
          <addressOffset>0x4010196C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR11_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 11</description>
          <addressOffset>0x40101970</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR11_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 11</description>
          <addressOffset>0x40101974</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR11_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 11</description>
          <addressOffset>0x40101978</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR11_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 11</description>
          <addressOffset>0x4010197C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR12_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 12</description>
          <addressOffset>0x40101980</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR12_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 12</description>
          <addressOffset>0x40101984</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR12_PING_CTL</name>
          <description>Descriptor 0 control register for channel 12</description>
          <addressOffset>0x40101988</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR12_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 12</description>
          <addressOffset>0x4010198C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR12_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 12</description>
          <addressOffset>0x40101990</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR12_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 12</description>
          <addressOffset>0x40101994</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR12_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 12</description>
          <addressOffset>0x40101998</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR12_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 12</description>
          <addressOffset>0x4010199C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR13_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 13</description>
          <addressOffset>0x401019A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR13_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 13</description>
          <addressOffset>0x401019A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR13_PING_CTL</name>
          <description>Descriptor 0 control register for channel 13</description>
          <addressOffset>0x401019A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR13_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 13</description>
          <addressOffset>0x401019AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR13_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 13</description>
          <addressOffset>0x401019B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR13_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 13</description>
          <addressOffset>0x401019B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR13_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 13</description>
          <addressOffset>0x401019B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR13_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 13</description>
          <addressOffset>0x401019BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR14_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 14</description>
          <addressOffset>0x401019C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR14_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 14</description>
          <addressOffset>0x401019C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR14_PING_CTL</name>
          <description>Descriptor 0 control register for channel 14</description>
          <addressOffset>0x401019C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR14_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 14</description>
          <addressOffset>0x401019CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR14_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 14</description>
          <addressOffset>0x401019D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR14_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 14</description>
          <addressOffset>0x401019D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR14_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 14</description>
          <addressOffset>0x401019D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR14_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 14</description>
          <addressOffset>0x401019DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR15_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 15</description>
          <addressOffset>0x401019E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR15_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 15</description>
          <addressOffset>0x401019E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR15_PING_CTL</name>
          <description>Descriptor 0 control register for channel 15</description>
          <addressOffset>0x401019E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR15_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 15</description>
          <addressOffset>0x401019EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR15_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 15</description>
          <addressOffset>0x401019F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR15_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 15</description>
          <addressOffset>0x401019F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR15_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 15</description>
          <addressOffset>0x401019F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR15_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 15</description>
          <addressOffset>0x401019FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR16_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 16</description>
          <addressOffset>0x40101A00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR16_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 16</description>
          <addressOffset>0x40101A04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR16_PING_CTL</name>
          <description>Descriptor 0 control register for channel 16</description>
          <addressOffset>0x40101A08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR16_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 16</description>
          <addressOffset>0x40101A0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR16_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 16</description>
          <addressOffset>0x40101A10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR16_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 16</description>
          <addressOffset>0x40101A14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR16_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 16</description>
          <addressOffset>0x40101A18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR16_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 16</description>
          <addressOffset>0x40101A1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR17_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 17</description>
          <addressOffset>0x40101A20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR17_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 17</description>
          <addressOffset>0x40101A24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR17_PING_CTL</name>
          <description>Descriptor 0 control register for channel 17</description>
          <addressOffset>0x40101A28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR17_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 17</description>
          <addressOffset>0x40101A2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR17_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 17</description>
          <addressOffset>0x40101A30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR17_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 17</description>
          <addressOffset>0x40101A34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR17_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 17</description>
          <addressOffset>0x40101A38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR17_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 17</description>
          <addressOffset>0x40101A3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR18_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 18</description>
          <addressOffset>0x40101A40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR18_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 18</description>
          <addressOffset>0x40101A44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR18_PING_CTL</name>
          <description>Descriptor 0 control register for channel 18</description>
          <addressOffset>0x40101A48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR18_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 18</description>
          <addressOffset>0x40101A4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR18_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 18</description>
          <addressOffset>0x40101A50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR18_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 18</description>
          <addressOffset>0x40101A54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR18_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 18</description>
          <addressOffset>0x40101A58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR18_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 18</description>
          <addressOffset>0x40101A5C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR19_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 19</description>
          <addressOffset>0x40101A60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR19_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 19</description>
          <addressOffset>0x40101A64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR19_PING_CTL</name>
          <description>Descriptor 0 control register for channel 19</description>
          <addressOffset>0x40101A68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR19_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 19</description>
          <addressOffset>0x40101A6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR19_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 19</description>
          <addressOffset>0x40101A70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR19_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 19</description>
          <addressOffset>0x40101A74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR19_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 19</description>
          <addressOffset>0x40101A78</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR19_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 19</description>
          <addressOffset>0x40101A7C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR20_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 20</description>
          <addressOffset>0x40101A80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR20_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 20</description>
          <addressOffset>0x40101A84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR20_PING_CTL</name>
          <description>Descriptor 0 control register for channel 20</description>
          <addressOffset>0x40101A88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR20_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 20</description>
          <addressOffset>0x40101A8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR20_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 20</description>
          <addressOffset>0x40101A90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR20_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 20</description>
          <addressOffset>0x40101A94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR20_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 20</description>
          <addressOffset>0x40101A98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR20_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 20</description>
          <addressOffset>0x40101A9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR21_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 21</description>
          <addressOffset>0x40101AA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR21_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 21</description>
          <addressOffset>0x40101AA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR21_PING_CTL</name>
          <description>Descriptor 0 control register for channel 21</description>
          <addressOffset>0x40101AA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR21_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 21</description>
          <addressOffset>0x40101AAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR21_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 21</description>
          <addressOffset>0x40101AB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR21_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 21</description>
          <addressOffset>0x40101AB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR21_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 21</description>
          <addressOffset>0x40101AB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR21_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 21</description>
          <addressOffset>0x40101ABC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR22_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 22</description>
          <addressOffset>0x40101AC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR22_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 22</description>
          <addressOffset>0x40101AC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR22_PING_CTL</name>
          <description>Descriptor 0 control register for channel 22</description>
          <addressOffset>0x40101AC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR22_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 22</description>
          <addressOffset>0x40101ACC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR22_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 22</description>
          <addressOffset>0x40101AD0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR22_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 22</description>
          <addressOffset>0x40101AD4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR22_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 22</description>
          <addressOffset>0x40101AD8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR22_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 22</description>
          <addressOffset>0x40101ADC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR23_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 23</description>
          <addressOffset>0x40101AE0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR23_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 23</description>
          <addressOffset>0x40101AE4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR23_PING_CTL</name>
          <description>Descriptor 0 control register for channel 23</description>
          <addressOffset>0x40101AE8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR23_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 23</description>
          <addressOffset>0x40101AEC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR23_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 23</description>
          <addressOffset>0x40101AF0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR23_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 23</description>
          <addressOffset>0x40101AF4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR23_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 23</description>
          <addressOffset>0x40101AF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR23_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 23</description>
          <addressOffset>0x40101AFC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR24_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 24</description>
          <addressOffset>0x40101B00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR24_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 24</description>
          <addressOffset>0x40101B04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR24_PING_CTL</name>
          <description>Descriptor 0 control register for channel 24</description>
          <addressOffset>0x40101B08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR24_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 24</description>
          <addressOffset>0x40101B0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR24_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 24</description>
          <addressOffset>0x40101B10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR24_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 24</description>
          <addressOffset>0x40101B14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR24_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 24</description>
          <addressOffset>0x40101B18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR24_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 24</description>
          <addressOffset>0x40101B1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR25_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 25</description>
          <addressOffset>0x40101B20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR25_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 25</description>
          <addressOffset>0x40101B24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR25_PING_CTL</name>
          <description>Descriptor 0 control register for channel 25</description>
          <addressOffset>0x40101B28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR25_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 25</description>
          <addressOffset>0x40101B2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR25_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 25</description>
          <addressOffset>0x40101B30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR25_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 25</description>
          <addressOffset>0x40101B34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR25_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 25</description>
          <addressOffset>0x40101B38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR25_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 25</description>
          <addressOffset>0x40101B3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR26_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 26</description>
          <addressOffset>0x40101B40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR26_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 26</description>
          <addressOffset>0x40101B44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR26_PING_CTL</name>
          <description>Descriptor 0 control register for channel 26</description>
          <addressOffset>0x40101B48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR26_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 26</description>
          <addressOffset>0x40101B4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR26_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 26</description>
          <addressOffset>0x40101B50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR26_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 26</description>
          <addressOffset>0x40101B54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR26_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 26</description>
          <addressOffset>0x40101B58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR26_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 26</description>
          <addressOffset>0x40101B5C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR27_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 27</description>
          <addressOffset>0x40101B60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR27_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 27</description>
          <addressOffset>0x40101B64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR27_PING_CTL</name>
          <description>Descriptor 0 control register for channel 27</description>
          <addressOffset>0x40101B68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR27_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 27</description>
          <addressOffset>0x40101B6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR27_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 27</description>
          <addressOffset>0x40101B70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR27_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 27</description>
          <addressOffset>0x40101B74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR27_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 27</description>
          <addressOffset>0x40101B78</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR27_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 27</description>
          <addressOffset>0x40101B7C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR28_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 28</description>
          <addressOffset>0x40101B80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR28_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 28</description>
          <addressOffset>0x40101B84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR28_PING_CTL</name>
          <description>Descriptor 0 control register for channel 28</description>
          <addressOffset>0x40101B88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR28_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 28</description>
          <addressOffset>0x40101B8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR28_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 28</description>
          <addressOffset>0x40101B90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR28_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 28</description>
          <addressOffset>0x40101B94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR28_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 28</description>
          <addressOffset>0x40101B98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR28_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 28</description>
          <addressOffset>0x40101B9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR29_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 29</description>
          <addressOffset>0x40101BA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR29_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 29</description>
          <addressOffset>0x40101BA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR29_PING_CTL</name>
          <description>Descriptor 0 control register for channel 29</description>
          <addressOffset>0x40101BA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR29_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 29</description>
          <addressOffset>0x40101BAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR29_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 29</description>
          <addressOffset>0x40101BB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR29_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 29</description>
          <addressOffset>0x40101BB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR29_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 29</description>
          <addressOffset>0x40101BB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR29_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 29</description>
          <addressOffset>0x40101BBC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR30_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 30</description>
          <addressOffset>0x40101BC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR30_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 30</description>
          <addressOffset>0x40101BC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR30_PING_CTL</name>
          <description>Descriptor 0 control register for channel 30</description>
          <addressOffset>0x40101BC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR30_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 30</description>
          <addressOffset>0x40101BCC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR30_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 30</description>
          <addressOffset>0x40101BD0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR30_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 30</description>
          <addressOffset>0x40101BD4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR30_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 30</description>
          <addressOffset>0x40101BD8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR30_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 30</description>
          <addressOffset>0x40101BDC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR31_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 31</description>
          <addressOffset>0x40101BE0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR31_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 31</description>
          <addressOffset>0x40101BE4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR31_PING_CTL</name>
          <description>Descriptor 0 control register for channel 31</description>
          <addressOffset>0x40101BE8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR31_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 31</description>
          <addressOffset>0x40101BEC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR31_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 31</description>
          <addressOffset>0x40101BF0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR31_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 31</description>
          <addressOffset>0x40101BF4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR31_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 31</description>
          <addressOffset>0x40101BF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR31_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 31</description>
          <addressOffset>0x40101BFC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CAN</name>
      <description>No description available</description>
      <baseAddress>0x0</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CAN_CAN_INT_SR</name>
          <description>The interrupt status register stores internal interrupt events.  ? Once a bit is set it remains set until it is cleared by writing a '1' to it.  ? The interrupt enable register has no effect on the interrupt status register.  ? A pending interrupt occurs when the flag is set to '1'. To acknowledge an interrupt, set the flag to '1'</description>
          <addressOffset>0x402F0000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ARB_LOSS</name>
              <description>Arbitration Loss</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OVR_LOAD</name>
              <description>Overload Interrupt</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ERR</name>
              <description>Bit Error Interrupt</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STUF_ERR</name>
              <description>Stuff Error Interrupt</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ACK_ERR</name>
              <description>Ack Error Interrupt</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FORM_ERR</name>
              <description>Form Error Interrupt</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_ERR</name>
              <description>CRC Error Interrupt</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_OFF</name>
              <description>Bus Off State</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG_LOSS</name>
              <description>Rx msg loss Interrupt</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_MSG</name>
              <description>Tx msg Sent</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG</name>
              <description>Msg Recieved</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RTR_MSG</name>
              <description>RTR auto-reply message sent</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STUCK_AT_ZERO</name>
              <description>Stuck at dominant error</description>
              <lsb>14</lsb>
              <msb>14</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SST_FAILURE</name>
              <description>Single shot transmission failure</description>
              <lsb>15</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_BUF_SR</name>
          <description>These status indicators bundle the respective flags from all RxMessage and TxMessage buffers.  ? Note All flags are read only. To acknowledge a MsgAv flag, the CPU must write to the respective RxMessage buffer</description>
          <addressOffset>0x402F0008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RX_MSG0</name>
              <description>Rx Msg0 Available</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG1</name>
              <description>Rx Msg1 Available</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG2</name>
              <description>Rx Msg2 Available</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG3</name>
              <description>Rx Msg3 Available</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG4</name>
              <description>Rx Msg4 Available</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG5</name>
              <description>Rx Msg5 Available</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG6</name>
              <description>Rx Msg6 Available</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG7</name>
              <description>Rx Msg7 Available</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG8</name>
              <description>Rx Msg8 Available</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG9</name>
              <description>Rx Msg9 Available</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG10</name>
              <description>Rx Msg10 Available</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG11</name>
              <description>Rx Msg11 Available</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG12</name>
              <description>Rx Msg12 Available</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG13</name>
              <description>Rx Msg13 Available</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG14</name>
              <description>Rx Msg14 Available</description>
              <lsb>14</lsb>
              <msb>14</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG15</name>
              <description>Rx Msg15 Available</description>
              <lsb>15</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_MSG0</name>
              <description>Tx req Pending for Tx Msg0</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_MSG1</name>
              <description>Tx req Pending for Tx Msg1</description>
              <lsb>17</lsb>
              <msb>17</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_MSG2</name>
              <description>Tx req Pending for Tx Msg2</description>
              <lsb>18</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_MSG3</name>
              <description>Tx req Pending for Tx Msg3</description>
              <lsb>19</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_MSG4</name>
              <description>Tx req Pending for Tx Msg4</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_MSG5</name>
              <description>Tx req Pending for Tx Msg5</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_MSG6</name>
              <description>Tx req Pending for Tx Msg6</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_MSG7</name>
              <description>Tx req Pending for Tx Msg7</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_ERR_SR</name>
          <description>Status indicators are provided to report the CAN controller error state, receive error count, and transmit error count. ? Special flags report error counter values equal to or in excess of 96 errors are available to indicate heavily disturbed bus situations.  ? The transmitter error counter according to the CAN standard. When it is greater than 255 Decimal, it is fixed at 255 Decimal.</description>
          <addressOffset>0x402F000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TX_ERR_CNT</name>
              <description>Tx error Count</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_ERR_CNT</name>
              <description>Rx error Count. When in bus-off state,this counter is used to count 128 groups of 11 recessive bits</description>
              <lsb>8</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_STATE</name>
              <description>Error State of CAN node, 00 error active, 01 error passive, 1x bus off</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TXGTE96</name>
              <description>Tx Error Count is greater or equal to 96 Decimal</description>
              <lsb>18</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RXGTE96</name>
              <description>Rx Error Count is greater or equal to 96 Decimal</description>
              <lsb>19</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_ECR</name>
          <description>The Error Capture register operates in two different modes: ? Free running mode - ECR displays the fiels and bit positions within the current CAN frame ? Error Capture mode - ECR samples the field and bit position when a CAN error is detected ? In order to sample such an event, the ECR needs to be armed by performing a write access to it. ? When armed, the ECR only captures one error event.  ? For successive error captures, the ECR needs to be armed again.</description>
          <addressOffset>0x402F0018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ECR_STATUS</name>
              <description>ECR STATUS: ?         0: ECR register captured an error, or it is in free running mode ?         1: ECR register is armed</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ERROR_TYPE</name>
              <description>Error type: ?         000 : Arbitration loss ?         001 : Bit Error ?         010 : Bit Stuffing Error ?         011 : Acknowledge Error ?         100 : Form Error ?         101 : CRC Error ?         Others : N/A</description>
              <lsb>1</lsb>
              <msb>3</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_MODE</name>
              <description>RX Mode: ?         0: No status ?         1: CAN Controller is receiver</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_MODE</name>
              <description>TX Mode: ?         0: No status ?         1: CAN Controller is transmitter</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>BIT</name>
              <description>Bit number inside of Field</description>
              <lsb>6</lsb>
              <msb>11</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>Field</name>
              <description>Field: ?         0x00 : Stopped ?         0x01 : Synchronize ?         0x05 : Interframe ?         0x06 : Bus Idle ?         0x07 : Start of Frame ?         0x08 : Arbitration ?         0x09 : Control ?         0x0A : Data ?         0x0B : CRC ?         0x0C : ACK ?         0x0D : End of frame ?         0x10 : Error flag ?         0x11 : Error echo ?         0x12 : Error delimiter ?         0x18 : Overload flag ?         0x19 : Overload echo ?         0x1A : Overload delimiter ?         Others : N/A</description>
              <lsb>12</lsb>
              <msb>16</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX0_ID</name>
          <description>CAN Tx Msg Identifier</description>
          <addressOffset>0x402F0024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Tx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX0_DH</name>
          <description>CAN Tx Msg Upper Data Bytes</description>
          <addressOffset>0x402F0028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX0_DL</name>
          <description>CAN Tx Msg Lower Data Bytes</description>
          <addressOffset>0x402F002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX1_ID</name>
          <description>CAN Tx Msg Identifier</description>
          <addressOffset>0x402F0034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Tx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX1_DH</name>
          <description>CAN Tx Msg Upper Data Bytes</description>
          <addressOffset>0x402F0038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX1_DL</name>
          <description>CAN Tx Msg Lower Data Bytes</description>
          <addressOffset>0x402F003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX2_ID</name>
          <description>CAN Tx Msg Identifier</description>
          <addressOffset>0x402F0044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Tx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX2_DH</name>
          <description>CAN Tx Msg Upper Data Bytes</description>
          <addressOffset>0x402F0048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX2_DL</name>
          <description>CAN Tx Msg Lower Data Bytes</description>
          <addressOffset>0x402F004C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX3_ID</name>
          <description>CAN Tx Msg Identifier</description>
          <addressOffset>0x402F0054</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Tx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX3_DH</name>
          <description>CAN Tx Msg Upper Data Bytes</description>
          <addressOffset>0x402F0058</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX3_DL</name>
          <description>CAN Tx Msg Lower Data Bytes</description>
          <addressOffset>0x402F005C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX4_ID</name>
          <description>CAN Tx Msg Identifier</description>
          <addressOffset>0x402F0064</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Tx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX4_DH</name>
          <description>CAN Tx Msg Upper Data Bytes</description>
          <addressOffset>0x402F0068</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX4_DL</name>
          <description>CAN Tx Msg Lower Data Bytes</description>
          <addressOffset>0x402F006C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX5_ID</name>
          <description>CAN Tx Msg Identifier</description>
          <addressOffset>0x402F0074</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Tx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX5_DH</name>
          <description>CAN Tx Msg Upper Data Bytes</description>
          <addressOffset>0x402F0078</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX5_DL</name>
          <description>CAN Tx Msg Lower Data Bytes</description>
          <addressOffset>0x402F007C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX6_ID</name>
          <description>CAN Tx Msg Identifier</description>
          <addressOffset>0x402F0084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Tx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX6_DH</name>
          <description>CAN Tx Msg Upper Data Bytes</description>
          <addressOffset>0x402F0088</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX6_DL</name>
          <description>CAN Tx Msg Lower Data Bytes</description>
          <addressOffset>0x402F008C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX7_ID</name>
          <description>CAN Tx Msg Identifier</description>
          <addressOffset>0x402F0094</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Tx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX7_DH</name>
          <description>CAN Tx Msg Upper Data Bytes</description>
          <addressOffset>0x402F0098</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX7_DL</name>
          <description>CAN Tx Msg Lower Data Bytes</description>
          <addressOffset>0x402F009C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX0_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402F00A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX0_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402F00A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX0_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402F00AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX1_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402F00C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX1_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402F00C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX1_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402F00CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX2_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402F00E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX2_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402F00E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX2_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402F00EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX3_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402F0104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX3_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402F0108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX3_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402F010C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX4_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402F0124</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX4_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402F0128</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX4_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402F012C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX5_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402F0144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX5_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402F0148</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX5_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402F014C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX6_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402F0164</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX6_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402F0168</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX6_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402F016C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX7_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402F0184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX7_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402F0188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX7_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402F018C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX8_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402F01A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX8_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402F01A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX8_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402F01AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX9_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402F01C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX9_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402F01C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX9_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402F01CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX10_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402F01E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX10_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402F01E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX10_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402F01EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX11_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402F0204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX11_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402F0208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX11_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402F020C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX12_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402F0224</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX12_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402F0228</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX12_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402F022C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX13_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402F0244</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX13_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402F0248</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX13_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402F024C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX14_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402F0264</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX14_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402F0268</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX14_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402F026C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX15_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402F0284</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX15_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402F0288</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX15_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402F028C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>